Міністерство освіти і науки України
Харківський національний університет радіоелектроніки

Факультет комп’ютерних наук
Кафедра програмної інженерії

КУРСОВА РОБОТА
ПОЯСНЮВАЛЬНА ЗАПИСКА
з навчальної дисципліни «Архітектура програмного забезпечення»
Тема роботи: Програмна система для управління груповими подорожами     (TravelSync)

Студент гр. ПЗПІ-21-3  	__________________ Топчій Д.Д
(підпис)

Керівник роботи 			___________________ доц. Лещинський В.О.
(підпис)
    Роботу захищено «__»_________2024 р.
    з оцінкою _________________________

Комісія: 				___________________ доц. Лещинський В.О.
(підпис)	
___________________ доц. Лещинська І.О.
(підпис)
___________________ ст.викл. Сокорчук І.П.
(підпис)

Харків
2024 р.
Харківський національний університет радіоелектроніки 


Факультет комп’ютерних наук      .Кафедра програмної інженерії              .
Спеціальність 121-Інженерія програмного забезпечення                              .
Курс 3              Семестр _________________6_________________________ 
Дисципліна Архітектура програмного забезпечення_______________ 

ЗАВДАННЯ 
НА КУРСОВУ РОБОТУ СТУДЕНТОВІ 
                                        Топчій Дар’ї Дмитрівни                                             .
1. Тема проєкту: «Програмна система для управління груповими подорожами „TravelSync“»                                                                           . 
2. Термін узгодження завдання з лабораторних робіт «19» лютого  2024 р. 
3. Термін здачі завдання з лабораторних робіт «25»  травня   2024 р. 
4. Вихідні дані до проєкту: В програмній системі передбачити:відстеження стану користувача, додавання та редагування користувача, подорожі, організація подорожей.
5. Зміст звітів з лабораторних робіт (перелік питань, що належить розробити): вступ, аналіз предметної області, постановка задачі, проектування                   .
програмного проекту, структура бази даних, кодування програмного                  .
проекту, опис розробленої програмної системи, висновки, перелік посилань,           .      
додатки                                                                                                                            .
6. Перелік графічного матеріалу (діаграми, рисунки, інтерфейси): Deployment Diagram, Use Case Diagram, ER-модель даних, Package Diagram, Interaction Overview Diagram, Activity Diagram, інтерфейс головної сторінки                          .

КАЛЕНДАРНИЙ ПЛАН


№	Основні етапи виконання проєкту в рамках лабораторних робіт	Термін виконання етапів	Примітка
1	Функціональна специфікація
програмного проекту	26.02.2024	виконано
2	Проектування програмного
проекту	04.03.2024	виконано
3	Кодування програмного проекту	20.05.2024	виконано
4	Оформлення пояснювальної
записки	05.06.2024	виконано
5	Захист курсової роботи	17.06.2024	виконано

Дата видачі теми проєкту «19» лютого 2024 р. 

Викладач лабораторних робіт 		_____________ ст. викл. Сокорчук І.П.

Завдання прийняв до виконання 
ст. гр. ПЗПІ-21-3 						_____________	 Топчій Д.Д


РЕФЕРАТ


Пояснювальна записка до курсової роботи: 48 с., 6 рис., 8 додатків, джерела. 
АРХІТЕКТУРА, ПОДОРОЖІ, ОРГАНІЗАЦІЯ, ПРОГРАМУВАННЯ, СИСТЕМА, ПУЛЬС
Об'єктом дослідження курсової роботи є розробка програмної системи для організації та координації групових подорожей, яка включає серверний застосунок, IoT-застосунок та веб-додаток.
Метою курсової роботи є проектування та розробка програмної системи, що базується на сучасних принципах проектування архітектури програмного забезпечення, включаючи архітектурні шаблони та стилі, методики побудови архітектури програмного забезпечення, проектування шару представлення, бізнес-шару, шару доступу до даних та шару сервісів.
Розробка системи базується на використанні трирівневої архітектури (BLL, DAL, API) та RESTful підходу для забезпечення стандартизованої взаємодії між компонентами. Для бази даних використано Microsoft SQL Server Management Studio та Entity Framework з принципом "Code First". IoT-пристрій було створено з використанням технології Arduino та чипа ESP32 для відстеження GPS і пульсу, а веб-додаток розроблено з використанням Angular 18 [3].
В результаті виконання курсової роботи було створено програмну систему, яка значно спрощує процес організації та координації групових подорожей. Система забезпечує зручність та надійність у плануванні маршрутів, бронюванні транспорту та проживання, а також у комунікації між учасниками подорожі.
ЗМІСТ


Вступ................................................................................................................	7
1 АНАЛІЗ ПРЕДМЕТНОЇ ОБЛАСТІ.........................................…..………	8
   1.1 Загальний огляд предметної області...................................................	8
   1.2 Аналіз існуючих аналогів.………………………………..…….….....	9
2 ПОСТАНОВКА ЗАВДАННЯ.....................................................................	10
   2.1 Затвердження бачення програмної системи........................................	10
   2.2 Користувачі системи та потреби цільового ринку..............................	10
   2.3 Припущення та залежності...................................................................	11
   2.4 Основний функціонал та сценарії використання системи.................	12
   2.5 Ризики програмної системи..................................................................	13
   2.6 Обмеження та винятки .........................................................................	13
   2.7 Вимоги до програмної системи та стек технологій............................	14
3 АРХІТЕКТУРА Й ПРОЄКТУВАННЯ СИСТЕМИ...................................	16
   3.1 UML-моделювання................................................................................	16
   3.2 Проєктування бази даних......................................................................	16
   3.3 Загальна архітектура програмної системи...........................................	17
   3.4 Архітектура серверної частини............................................................	17
   3.5 Архітектура ІоТ......................................................................................	18
4 ОПИС ПРОГРАМНИХ РІШЕНЬ...............................................................	19
   4.1 Програмні рішення серверного застосунку.........................................	19
      4.1.1 Робота з базою даних.......................................................................	19
      4.1.2 Автентифікація................................................................................	19
      4.1.3 Специфікація REST API..................................................................	20
      4.1.4 Валідація на сервері.........................................................................	20
      4.1.5 Локалізація.......................................................................................	21
      4.1.6 Використання механізму Dependency Injection.............................	21
      4.1.7 Забезпечення безпеки даних...........................................................	22
   4.2 Програмні рішення ІоТ-застосунку......................................................	22
      4.2.1 Формування запитів.........................................................................	22
      4.2.2 Локалізація.......................................................................................	23
      4.2.3 Обчислення статистики...................................................................	23
      4.2.4 Адміністрування пристрою............................................................	24
ВИСНОВКИ....................................................................................................	25
ПЕРЕЛІК ДЖЕРЕЛ ПОСИЛАННЯ..............................................................	26
ДОДАТОК А UML-діаграма прецедентів...................................................	27
ДОДАТОК Б UML-діаграма розгортання....................................................	29
ДОДАТОК В ER-діаграма.............................................................................	30
ДОДАТОК Г UML-діаграма пакетів............................................................	31
ДОДАТОК Д Код GenericRepository............................................................	32

ВСТУП


У сучасному світі туризм стає все більш популярним і доступним для широкої аудиторії. Групові подорожі є привабливим варіантом проведення вільного часу для багатьох людей, оскільки вони надають соціальну взаємодію, безпеку і можливість ділитися враженнями з іншими учасниками. Проте організація і координація групових подорожей можуть бути складними завданнями для організаторів і учасників. На основі цієї потреби виникає необхідність у створенні програмної системи, яка об'єднала б у собі функціональність організації подорожей.
Метою виконання курсової роботи є проектування та розробка програмного проекту з використанням основних принципів проектування архітектури програмного забезпечення, архітектурних шаблонів та стилів, методики побудови архітектури програмного забезпечення, проектування шару представлення, бізнес-шару, шару доступу до даних, шару сервісів. Основна ідея полягає у створенні зручної та надійної системи, яка забезпечить користувачам простоту у плануванні та координації групових подорожей. Для досягнення мети виконано такі завдання: вивчення можливих варіантів архітектур програмного забезпечення, патернів проектування, принципів «чистого» коду, аналіз предметної області, галузі застосування та впровадження програмного рішення, проектування системи та бази даних, програмна реалізація задуму з дотриманням принципів «чистого» коду та «чистої» архітектури.
Розроблений проект забезпечує зручність та надійність у плануванні групових подорожей. Він містить інформацію про учасників подорожі, надає можливість комунікації між користувачами системи, бронювання транспорту та проживання, а також планування маршрутів та заходів. Наш продукт дає можливість користувачам здійснювати всі необхідні дії за допомогою мобільного додатку, що робить процес організації подорожей більш ефективним та комфортним.
В результаті виконання курсової роботи ми отримуємо проєкт, який значно спрощує процес організації та координації групових подорожей. Використання сучасних принципів та методик програмної інженерії дозволяє створити надійний і зручний інструмент для усіх учасників подорожі, забезпечуючи їхню безпеку та комфорт.

1	АНАЛІЗ ПРЕДМЕТНОЇ ОБЛАСТІ
1.1	Загальний огляд предметної області


Туризм стає все більш популярним і доступним для широкої аудиторії, що призводить до зростання попиту на організацію групових подорожей. Групові подорожі є привабливим варіантом проведення вільного часу, оскільки вони надають соціальну взаємодію, безпеку і можливість ділитися враженнями з іншими учасниками. Проте організація і координація групових подорожей є складними завданнями для організаторів та учасників. Відсутність ефективних інструментів для планування, бронювання та комунікації між учасниками подорожі може створювати значні труднощі.
На основі цих потреб можна виділити наступні аспекти предметної області:
	планування подорожей;
	комунікація між учасниками подорожі;
	бронювання транспорту та проживання;
	організація маршрутів та заходів.
Система має надавати послуги з планування подорожей, комунікації між учасниками, бронювання транспорту та проживання, а також створення маршрутів та заходів. Основна мета системи — спростити процес організації та координації групових подорожей, зробити його більш зручним та ефективним для організаторів та учасників.
Система була розроблена для людей, що органують групових подорожей, зокрема для туристичних агенцій, груп друзів, родин та інших колективів, які бажають спільно подорожувати та отримувати незабутні враження від поїздок. Вона допоможе забезпечити безперервний зв'язок між учасниками, організувати зручний процес бронювання та забезпечити безпеку під час подорожей.

1.2	Аналіз аналогів системи


Система "TravelSync" конкурує з різноманітними програмами та сервісами, що надають послуги з організації подорожей. Зокрема, порівняно з "AllTrails", який спеціалізується на маршрутах для пішоходів та прогулянок, "TravelSync" вирізняється інтегрованим функціоналом для групових подорожей та відстеження учасників, що робить його більш зручним для організаторів і учасників.
"Viator", який спеціалізується на екскурсіях з гідом, не має інтегрованих інструментів для організації групових подорожей та моніторингу учасників, у той час, як "TravelSync" забезпечує ці функції, а також використовує IoT пристрої для покращення безпеки та комфорту під час подорожей. У "Travello", соціальній мережі для мандрівників, також відсутній функціонал для організації та планування групових подорожей, що робить "TravelSync" більш привабливим варіантом для користувачів, які шукають інтегровані рішення.
У порівнянні з сайтами пошуку та бронювання подорожей, такими як "Kayak.com" та "Orbitz", які надають широкий спектр послуг, "TravelSync" видається більш важливою альтернативою для організаторів та учасників подорожей, оскільки він надає інтегрований функціонал для групових подорожей та відстеження учасників."TravelSync" пропонує розв’язання цієї проблеми, надаючи інтегрований функціонал для організації та координації групових подорожей. Крім того, використання інтернету речей (IoT) для відстеження учасників подорожей підвищує безпеку та комфорт, що робить "TravelSync" привабливим рішенням для організаторів та учасників подорожей.
"TravelSync" має кілька моделей монетизації, включаючи продаж спеціальних браслетів для відстеження учасників, отримання комісійних з платних екскурсій через платформу та розміщення реклами на своєму вебсайті або додатку. Такий підхід дозволяє "TravelSync" створювати прибуток та розвиватися на ринку мобільних додатків для подорожей.
2	ПОСТАНОВКА ЗАВДАННЯ
2.1	Затвердження бачення програмної системи.


Система TravelSync надаватиме інтерфес для організації та координації групових подорожей, що включають планування маршрутів, бронювання транспорту та проживання, а також комунікацію між учасниками подорожі. Основною метою є спрощення процесу організації групових подорожей, забезпечення безпеки та комфорту для всіх учасників. Користувачі зможуть створювати маршрути, додавати визначні місця та події, бронювати квитки та готелі, а також спілкуватися з іншими учасниками через зручний мобільний додаток.


2.2	Користувачі системи та потреби цільового ринку

Системою користуватимуться як організатори подорожей, так і учасники. Для кожної групи користувачів передбачено окремий функціонал. Потреби організаторів включають:
	Швидке та зручне планування подорожей;
	Бронювання транспорту та проживання;
	Координація з учасниками подорожі;
	Інформація про місцезнаходження та стан здоров'я учасників.
Учасники подорожей потребують:
	Можливість приєднуватися до групових подорожей;
	Зручний інтерфейс для комунікації;
	Інформація про маршрути та події;
	Безпечне замовлення послуг під час подорожі.

2.3	Припущення та залежності

Припущенн:
	Існує значний попит на спрощення організації групових подорожей;
	Технічна реалізація системи буде успішною та надійною;
	Система TravelSync зацікавить туристичні агенції та окремих мандрівників;
	Користувачі мають доступ до Інтернету для взаємодії з системою;
	Користувачі вміють користуватися мобільними додатками та завантажувати їх.
Проект залежить від успішної реалізації технологій для роботи GPS-браслетів та розробки програмного забезпечення. Успіх проекту також залежить від укладення партнерських угод з туристичними агенціями та забезпечення технічної підтримки для вирішення можливих проблем та відмов у роботі системи.


2.4	Основний функціонал та сценарії використання системи


	Основні функції для першої версії:
	Створення облікових записів користувачів.
	Планування маршрутів та додавання визначних місць.
	Відстеження місцезнаходження учасників за допомогою GPS-браслетів.
	Обмін повідомленнями між учасниками подорожей.
	Виклик екстреної допомоги в разі потреби.





2.5	Ризики програмної системи


Важливо враховувати ризики під час розробки системи. Для уникнення проблем з датчиками відстеження пульсу небхідно тестувати продукт перед виведенням його на ринок. Слід враховувати конкуренцію на ринку та постійно розробляти методи діференціації та реклами. 


2.6	Обмеження та винятки


	Використання симуляторів для тестування функцій до їх впровадження.
	Відсутність додаткового функціоналу у першому випуску.
	Залежність від наявності Інтернету та електропостачання для нормальної роботи системи.

2.7 Вимоги до програмної системи та стек технологій


	Запланований функціонал серверної частини: 
	Створення облікових записів для користувачів.
	Система авторизації та автентифікації.
	Зберігання інформації про маршрути та події на сервері.
	Створення запитів на бронювання приміщень або проведення подій.
	Комунікація між учасниками подорожей.

Запланований функціонал клієнтської частини: 
	 Локалізація веб-інтерфейсу,
	 Інтерфейс для взаємодіїї з системою, а саме створення та редагування обілкового запису, перегляд та створення подорожей.

	Запланований функціонал IoT частини: 
	 Надсилання даних про пульс та місце знаходження;
	 Визначення пульсу;

Для розробки серверної частини була використана платформа .NET 7 та мова програмування C#, використана СУБД MS SSMS та для взаємодії з нею EF Core. веб-додаток був розроблений використанням Angular Framework 18 версії [3], IoT девайс був запроєктований за допомогою технології Arduino.


3	АРХІТЕКТУРА Й ПРОЄКТУВАННЯ СИСТЕМИ
3.1	UML-моделювання

У додатках А, Б, Г наведені UML діаграми.

3.2	Проєктування бази даних


База даних містить 4 сутності: Користувач, Кімната, Користувач в кімнаті, Шлях. Сутності пов’язані між собою зв’язками один-до-багатьох та один-до-одного.
ER-модель даних представлено в Додатку В.

3.3	Загальна архітектура програмної системи 


Система має три головні частини: серверний додаток, IoT-додаток та веб-додаток. Функціонування системи базується на тому, що IoT-пристрій періодично зв'язується з сервером, що значно знижує навантаження на клієнтську частину, оскільки запити здійснюються тільки за необхідності.
Кожен компонент працює у своєму середовищі, а їх взаємодія здійснюється через протокол HTTP. Серверний додаток виступає як центральний вузол системи, обробляючи всі маніпуляції з даними. І веб-додаток, і IoT-пристрій здійснюють запити до сервера з використаням HTTP протоколу.
Ця архітектура забезпечує ефективну та стабільну роботу всіх компонентів системи, дозволяючи легко адаптувати її до потреб користувачів і бізнесу.
     

3.4	Архітектура серверної частини

Система побудована на трирівневій архітектурі, що включає бізнес-логічний рівень (BLL), рівень доступу до даних (DAL) та рівень API. На рівні бізнес-логіки обробляються всі основні операції та бізнес-процеси системи. Рівень доступу до даних відповідає за взаємодію з базою даних, забезпечуючи збереження та отримання інформації. API (інтерфейс програмування додатків) використовується для комунікації між клієнтськими додатками (веб та IoT) і сервером, реалізовуючи RESTful підхід, що дозволяє стандартизовано обробляти HTTP-запити і відповіді, забезпечуючи ефективний і безпечний обмін даними.


3.5	Архітектура ІоТ


Для розробки браслета, який відстежує GPS і пульс, була використана платформа Arduino разом з чипом ESP32, програмованим на мові C++. Arduino є популярною платформою для створення електронних пристроїв завдяки своїй простоті використання та великій спільноті підтримки. Чип ESP32 був обраний через його потужні можливості, включаючи вбудовані модулі Wi-Fi та Bluetooth, що дозволяють браслету ефективно обробляти та передавати дані.
Браслет оснащений датчиками для вимірювання пульсу та GPS-модулем для відстеження геолокації. Дані від цих сенсорів обробляються мікроконтролером ESP32, після чого кожну хвилину відправляються на сервер через Wi-Fi. Ця система забезпечує точний і постійний моніторинг фізичного стану користувача та його місцезнаходження в реальному часі, що може бути особливо корисним для спортивних тренувань, здоров'я та безпеки.
4	ОПИС ПРОГРАМНИХ РІШЕНЬ
4.1	Програмні рішення серверного застосунку
4.1.1	 Робота з базою даних

Для управління базою даних у проєкті була використана система управління базами даних (СУБД) Microsoft SQL Server Management Studio (SSMS) [2]. Для роботи з базою даних і реалізації рівня доступу до даних (DAL) використана Entity Framework [4q]. При цьому був використаний принцип "Code First", що дозволяє спочатку створювати класи моделі в коді, а потім автоматично генерувати відповідну структуру бази даних. Ці інструменти забезпечили надійне і ефективне управління даними, дозволяючи швидко виконувати операції CRUD (створення, читання, оновлення, видалення), а також забезпечувати високий рівень інтеграції та зручність у роботі з даними.

4.1.2	 Автентифікація


Для реалізації авторизації та автентифікації використовується JSON Web Token (JWT).
public string GenerateJwt(UserModel user)
{
    var tokenHandler = new JwtSecurityTokenHandler();
    var key = Encoding.ASCII.GetBytes(this.appSettings.SecretKey);
    var tokenDescriptor = new SecurityTokenDescriptor
    {
        Subject = new ClaimsIdentity(new Claim[]
        {
            new Claim("id", user.Id.ToString())
        }),
        Expires = DateTime.UtcNow.AddDays(this.appSettings.JwtExpirationTime),
        SigningCredentials = new SigningCredentials(new SymmetricSecurityKey(key), SecurityAlgorithms.HmacSha256Signature)
    };
    var token = tokenHandler.CreateToken(tokenDescriptor);
    return tokenHandler.WriteToken(token);
}


4.1.3	 Специфікація REST APІ


RESTful підхід, що дозволяє стандартизовано обробляти HTTP-запити і відповіді, забезпечуючи ефективний і безпечний обмін даними. Контролери були розроблены для сутностей, вони визначали маршрути.
Таблиця 1 – Специфікація REST API
Посилання	Метод	Призначення
/api/Registration	POST	Реєстрація користувача
/api/Login	POST	Аутентифікація користувача
/api/Administration/{id}/approve	POST	Затвердження кімнати за її ідентифікатором
/api/Room	GET	Отримання всіх кімнат
/api/Room/{id}	GET	Отримання кімнати за її ідентифікатором
/api/Room	POST	Створення нової кімнати
/api/Room/{id}	DELETE	Видалення кімнати за її ідентифікатором
/api/Room	PUT	Оновлення інформації про кімнату
/api/User/{id}	GET	Отримання користувача за його ідентифікатором
/api/User	POST	Створення нового користувача
/api/User/{id}	DELETE	Видалення користувача за його ідентифікатором
/api/User/{id}	PUT	Оновлення висоти користувача за його ідентифікатором
/api/User/{id}/activate	PUT	Активація користувача за його ідентифікатором
/api/Backup	POST	Створення бекапу бази даних


4.1.4	 Валідація на сервері


Валідація даних реалізовано за допомогою атрибутів.
1 [Required(ErrorMessage = "Login is required")] 
2 [MinLength(5, ErrorMessage = "Login must be at least 5 characters long")] 
3 public string Login { get; set; } 
4 [Required(ErrorMessage = "Password is required")] 
5 [MinLength(6, ErrorMessage = "Password must be at least 6 characters long")] 6 public string Password { get; set; }


4.1.5	 Локалізація


Локалізація серверної частини відбувається за рахунок переведення зросту користувача в метри, в той час як на клієнтській частини зріст може бути введений у футах.


4.1.6	 Використання механізму Dependency Injection


Для передачі залежностей у проекті використано механізм Dependency Injection (DI). DI дозволяє впроваджувати залежності у вигляді сервісів у класи, що їх потребують, під час виконання програми, що сприяє більшій гнучкості та тестованості коду.
Приклад реалізації DI у проекті можна побачити у методі ConfigureRoomServices. У цьому методі налаштовуються залежності для різних сервісів за допомогою інтерфейсів. Кожен сервіс реєструється у контейнері служб з певним життєвим циклом. У даному прикладі використовується життєвий цикл Scoped, що означає, що для кожного запиту (request) буде створено новий екземпляр сервісу.private static void ConfigureRoomServices(IServiceCollection services)

1	{

2	    Services.AddScoped<IroomService, RoomService>();

3	    services.AddScoped<IRoomPointsService, RoomPointsService>();

4	    services.AddScoped<IUserRoomsService, UserRoomsService>();

5	    services.AddScoped<IRoomApprovalService, RoomApprovalService>();

6	}



4.1.7	 Забезпечення безпеки даних

Для забезпечення безпеки даних у нашій програмній системі використано декілька ключових технологій та методів, таких як хешування паролів, використання Entity Framework та JSON.
Хешування паролів є важливим аспектом захисту даних користувачів. При зберіганні паролів у базі даних вони не зберігаються у відкритому вигляді. Замість цього, паролі хешуються за допомогою алгоритму хешування SHA-256. Це гарантує, що навіть у разі компрометації бази даних зловмисник не зможе отримати доступ до оригінальних паролів.


4.2	Програмні рішення ІоТ-застосунку
4.2.1	 Формування запитів

Браслет створений з використанням технології Arduino та чипа ESP32, що дозволяє збирати та передавати дані на сервер кожну хвилину. Дані про пульс отримуються з датчика пульсу, а дані про GPS - з модуля GPS, інтегрованого в браслет.
Приклад коду для зчитування даних з датчиків та відправлення їх на сервер:
1	void setup() 
2	{ Serial.begin(115200);
3	gpsSerial.begin(9600, SERIAL_8N1, 16, 17); 
4	WiFi.begin(ssid, password);

4.2.2	 Локалізація


Для забезпечення точного часу зчитування даних з браслета, час вимірювань перетворюється у формат UTC "%Y-%m-%dT%H:%M:%S.000Z". Це уніфікує час на сервері, спрощуючи обробку та аналіз отриманих даних.

4.2.4 Адміністрування пристрою

Браслет налаштовується через мобільний пристрій, що забезпечує зручність використання для кінцевого користувача. Використовуючи мобільний додаток, користувач може легко налаштувати параметри браслета, такі як частота зчитування даних, параметри мережі Wi-Fi та інші необхідні налаштування.

4.3	Програмні рішення Веб-застосунку
4.3.1	Архітектура веб-клієнта
Для розробки веб-клієнта було використано Angular версії 18. Цей сучасний фреймворк дозволяє створювати динамічні та масштабовані веб-застосунки з багатим функціоналом. Веб-клієнт взаємодіє з сервером через HTTP, що дозволяє забезпечити швидкий та безпечний обмін даними між користувачем та сервером. Використання Angular дозволяє ефективно реалізувати архітектуру з чітким розподілом на компоненти та сервіси, що спрощує підтримку та розширення функціоналу застосунку.
Веб-клієнт забезпечує користувачам широкий спектр функціональних можливостей, що дозволяють зручно планувати, організовувати та контролювати подорожі:
	Реєстрація та авторизація користувачів:
	Користувачі можуть зареєструвати новий акаунт, вказавши необхідну інформацію (ім'я користувача, email, пароль).
	Після реєстрації користувачі можуть увійти в систему, використовуючи email та пароль.
	Підтвердження реєстрації через email для підвищення безпеки.
	Персональний кабінет:
	Користувачі можуть переглядати та редагувати свій профіль, змінювати особисті дані та налаштування.
	Можливість перегляду історії своїх подорожей.
	Перегляд та створення подорожей:
	Користувачі можуть переглядати список доступних подорожей, сортувати їх за різними критеріями (дата, тривалість, популярність тощо).
	Можливість створювати нові подорожі, вказуючи всі необхідні деталі: маршрут, дати, учасників, транспорт та проживання.
	Збереження створених подорожей для подальшого редагування та перегляду.
Знімки екрани веб-застосунку знаходяться в Додатку Е.
Приклад коду:
getData(): Observable<any> 
{ return this.http.get<any>(`${this.apiUrl}/data`); }
 sendData(data: any): Observable<any> 
{ return this.http.post<any>(`${this.apiUrl}/data`, data); }

4.3.2	Локалізація

Локалізація веб застосунку здійснена через меожливість переключення між англійською та українською версіями ітерфейсу.


ВИСНОВКИ

У рамках даної курсової роботи було розроблено комплексну програмну систему для організації та координації групових подорожей, що включає серверний застосунок, IoT-застосунок та веб-додаток. Основною метою роботи було створення зручної та надійної системи, яка б полегшила процес планування, бронювання та комунікації між учасниками подорожі.
Система була побудована на основі трирівневої архітектури, що включає бізнес-логічний рівень (BLL), рівень доступу до даних (DAL) та рівень API. Це дозволило забезпечити модульність, гнучкість та легкість масштабування системи. Для реалізації взаємодії між компонентами використовувався RESTful підхід, що забезпечує ефективну та стандартизовану обробку HTTP-запитів і відповідей.
Для управління базою даних було використано систему управління базами даних Microsoft SQL Server Management Studio (SSMS) та ORM-інструмент Entity Framework з принципом "Code First". Це забезпечило надійне управління даними та швидке виконання операцій CRUD.
IoT-застосунок було створено з використанням технології Arduino та чипа ESP32, що дозволяє відстежувати GPS і пульс користувачів. Дані передаються на сервер кожну хвилину, забезпечуючи постійний моніторинг фізичного стану та місцезнаходження користувача.
Веб-додаток розроблено з використанням Angular 18, що забезпечує динамічну та масштабовану платформу для користувачів. Веб-клієнт забезпечує зручний інтерфейс для планування подорожей, бронювання послуг та комунікації між учасниками.
Результатом виконаної роботи є створення інтегрованої системи, яка значно спрощує процес організації та координації групових подорожей, забезпечуючи зручність, надійність та безпеку для всіх учасників. Використання сучасних технологій та архітектурних принципів дозволило створити надійний інструмент, який відповідає потребам сучасних користувачів та туристичних агентств.
ПЕРЕЛІК ДЖЕРЕЛ ПОСИЛАННЯ
1.	Офіційна сторінка Ajax Systems URL: https://ajax.systems/ua/ (дата звернення 10.05.2024р.)
2.	Офіційна сторінка Microsoft URL: https://www.microsoft.com/en-us/sql-server (дата звернення 10.05.2024р.)
3.	Документація Angular URL: https://angular.io/docs (дата звернення 10.05.2024р.)
4.	Документація Entity Framework URL: https://docs.microsoft.com/en-us/ef/ (дата звернення 10.05.2024р.)
5.	Демо функціонального тестування Програмної системи для автоматизації логістики інтернет-шопінгу. URL: https://youtu.be/VieWYGAf3vk
6.	Програмний код розробленої системи. URL: https://github.com/NureTopchiiDaria/apzkr-pzpi-21-3-topchii-daria (дата звернення: 27.06.2024).



ДОДАТОК А
UML-діаграма прецедентів


 
Рисунок А.1 – UML діаграма прецедентів для розробленої серверної частини системи «TravelSync»

 
Рисунок А.2 – UML діаграма прецедентів для розробленого IoT-застосунку системи «EduCheck»
ДОДАТОК Б
UML-діаграма розгортання


 
Рисунок Б.1 – UML діаграма розгортання
ДОДАТОК В
ER-діаграма


 
Рисунок В.1 – ER-діаграма для створення бази даних системи


ДОДАТОК Г
UML-діаграма пакетів


 
Рисунок Г.1 – UML-діаграма пакетів серверного частини проєкту

 
Рисунок Г.2 – UML-діаграма пакетів IoT-застосунку
Додаток Д
Код програми
 1 using System.Linq.Expressions;
 2 using AutoMapper;
 3 using BLL.Abstractions.Interfaces.UserInterfaces;
 4 using Core.DataClasses;
 5 using Core.DTOs;
 6 using Core.Models.UserModels;
 7 using DAL.Abstractions.Interfaces;
 8
 9 namespace BLL.Services.UserServices
10 {
11     internal class UserService : IUserService
12     {
13         private readonly IGenericStorageWorker<UserModel> storage;
14
15         private readonly IHashingService hashingService;
16
17         public UserService(IGenericStorageWorker<UserModel> storage, IHashingService hashingService)
18         {
19             this.storage = storage;
20             this.hashingService = hashingService;
21         }
22
23         public async Task<IEnumerable<UserModel>> GetByConditions(params Expression<Func<UserModel, bool>>[] conditions)
24         {
25             return await this.storage.GetByConditions(
26                 conditions);
27         }
28
29         public async Task<IEnumerable<UserModel>> GetActiveUsers(params Expression<Func<UserModel, bool>>[] additionalConditions)
30         {
31             additionalConditions = additionalConditions.Append(x => x.IsActive).ToArray();
32             return await this.GetByConditions(additionalConditions);
33         }
34
35         public async Task<UserModel> GetUserById(Guid id)
36         {
37             return (await this.GetByConditions(u => u.Id == id)).FirstOrDefault();
38         }
39
40         public async Task<OptionalResult<UserModel>> CreateNonActiveUser(UserCreateModel user)
41         {
42             if ((await this.GetByConditions(x => x.Email == user.Email)).Any())
43             {
44                 return new OptionalResult<UserModel>(false, $"User with email {user.Email} already exists");
45             }
46
47             var userModel = this.MapUserCreateModel(user);
48             await this.storage.Create(userModel);
49
50             return new OptionalResult<UserModel>(userModel);
51         }
52
53         public async Task<ExceptionalResult> Delete(Guid id)
54         {
55             var user = await this.GetUserById(id);
56             if (user is null)
57             {
58                 return new ExceptionalResult(false, $"User with id {id} does not exist");
59             }
60
61             await this.storage.Delete(user);
62
63             return new ExceptionalResult();
64         }
65
66         public async Task<OptionalResult<UserModel>> ActivateUser(Guid id)
67         {
68             var userData = new UserUpdateModel()
69             {
70                 Id = id,
71                 IsActive = true,
72             };
73
74             return await this.Update(userData, null);
75         }
76
77         public async Task<OptionalResult<UserModel>> Update(UserUpdateModel user, UserHeightDTO userHeightDTO)
78         {
79             if (await this.GetUserById(user.Id) is null)
80             {
81                 return new OptionalResult<UserModel>(false, $"User with id {user.Id} does not exist");
82             }
83
84             // Check if height is specified in feet
85             if (userHeightDTO.IsInFeet)
86             {
87                 float heightInMeters = this.ConvertFeetToMeters(userHeightDTO.Height);
88                 user.Height = heightInMeters;
89             }
90
91             var userModel = await this.MapUserUpdateModel(user);
92             await this.storage.Update(userModel);
93
94             return new OptionalResult<UserModel>(userModel);
95         }
96
97         private async Task<UserModel> MapUserUpdateModel(UserUpdateModel user)
98         {
99             var mapperConfig = new MapperConfiguration(cfg =>
100             {
101                 cfg.CreateMap<UserUpdateModel, UserModel>(MemberList.Source).ForAllMembers(opt => opt.AllowNull());
102             });
103             var mapper = new Mapper(mapperConfig);
104             var userObject = mapper.Map<UserModel>(user);
105             var changingUser = await this.GetUserById(user.Id);
106
107             foreach (var field in userObject.GetType().GetProperties())
108             {
109                 if (field.GetValue(userObject) is not null)
110                 {
111                     field.SetValue(changingUser, field.GetValue(userObject));
112                 }
113             }
114
115             if (user.Password is not null)
116             {
117                 changingUser.HashedPassword = this.hashingService.Hash(user.Password);
118             }
119
120             return changingUser;
121         }
122
123         private float ConvertFeetToMeters(float feet)
124         {
125             // Convert height from feet to meters
126             const float feetToMetersConversionFactor = 0.3048f;
127             return feet * feetToMetersConversionFactor;
128         }
129
130         private UserModel MapUserCreateModel(UserCreateModel user)
131         {
132             var mapperConfiguration = new MapperConfiguration(cfg => cfg.CreateMap<UserCreateModel, UserModel>());
133             var mapper = new Mapper(mapperConfiguration);
134             var userObject = mapper.Map<UserModel>(user);
135             userObject.HashedPassword = this.hashingService.Hash(user.Password);
136             userObject.IsActive = false;
137
138             return userObject;
139         }
140     }
141 }
 

1	#include <stdio.h>
2	#include <string.h>
3	#include "freertos/FreeRTOS.h"
4	#include "freertos/task.h"
5	#include "freertos/event_groups.h"
6	#include "esp_system.h"
7	#include "esp_wifi.h"
8	#include "esp_event.h"
9	#include "nvs_flash.h"
10	#include "esp_log.h"
11	#include "esp_http_client.h"
12	#include <inttypes.h>
13	#define WIFI_SSID "EWV-WLAN"
14	#define WIFI_PASS "Wlan4Ewv2018!"
15	#define SERVER_URL "http://192.168.100.227:5000/data"
16	static EventGroupHandle_t s_wifi_event_group;
17	#define WIFI_CONNECTED_BIT BIT0
18	#define WIFI_FAIL_BIT      BIT1
19	static const char *TAG = "wifi station";
20	static int s_retry_num = 0;
21	static const int MAX_RETRY = 10;
22	static void event_handler(void* arg, esp_event_base_t event_base, int32_t event_id, void* event_data)
23	{
24	if (event_base == WIFI_EVENT && event_id == WIFI_EVENT_STA_START) {
25	esp_wifi_connect();
26	ESP_LOGI(TAG, "WiFi started, attempting to connect...");
27	} else if (event_base == WIFI_EVENT && event_id ==
28	28WIFI_EVENT_STA_DISCONNECTED) {
29	if (s_retry_num < MAX_RETRY) {
30	 esp_wifi_connect();
31	s_retry_num++;
ESP_LOGI(TAG, "Retrying to connect to the AP, attempt %d", s_retry_num);
32	} else {
a.	xEventGroupSetBits(s_wifi_event_group, WIFI_FAIL_BIT);
i.	ESP_LOGE(TAG, "Failed to connect to the AP after %d attempts", s_retry_num);
33	}
34	} else if (event_base == IP_EVENT && event_id == IP_EVENT_STA_GOT_IP) {
35	ip_event_got_ip_t* event = (ip_event_got_ip_t*) event_data;
36	ESP_LOGI(TAG, "Got IP: %s", ip4addr_ntoa(&event->ip_info.ip));
37	s_retry_num = 0;
38	xEventGroupSetBits(s_wifi_event_group, WIFI_CONNECTED_BIT);
39	}
40	}-------------------
41	void wifi_init_sta(void)
42	{
43	s_wifi_event_group = xEventGroupCreate();

44	ESP_ERROR_CHECK(esp_netif_init());

45	ESP_ERROR_CHECK(esp_event_loop_create_default());
46	esp_netif_create_default_wifi_sta();

47	wifi_init_config_t cfg = WIFI_INIT_CONFIG_DEFAULT();
48	ESP_ERROR_CHECK(esp_wifi_init(&cfg));

49	esp_event_handler_instance_t instance_any_id;
50	esp_event_handler_instance_t instance_got_ip;
i.	ESP_ERROR_CHECK(esp_event_handler_instance_register(WIFI_EVENT, ESP_EVENT_ANY_ID, &event_handler, NULL, &instance_any_id));
ii.	ESP_ERROR_CHECK(esp_event_handler_instance_register(IP_EVENT, IP_EVENT_STA_GOT_IP, &event_handler, NULL, &instance_got_ip));

51	wifi_config_t wifi_config = {
52	.sta = {
a.	.ssid = WIFI_SSID,
b.	.password = WIFI_PASS,
53	},
54	};
55	ESP_ERROR_CHECK(esp_wifi_set_mode(WIFI_MODE_STA));
56	ESP_ERROR_CHECK(esp_wifi_set_config(ESP_IF_WIFI_STA, &wifi_config));
57	ESP_ERROR_CHECK(esp_wifi_start());

58	ESP_LOGI(TAG, "WiFi initialization finished.");

59	EventBits_t bits = xEventGroupWaitBits(s_wifi_event_group,
a.	WIFI_CONNECTED_BIT | WIFI_FAIL_BIT,
b.	pdFALSE,
c.	pdFALSE,
d.	portMAX_DELAY);

60	if (bits & WIFI_CONNECTED_BIT) {
a.	ESP_LOGI(TAG, "Connected to AP SSID:%s, password:%s", WIFI_SSID, WIFI_PASS);
61	} else if (bits & WIFI_FAIL_BIT) {
a.	ESP_LOGI(TAG, "Failed to connect to SSID:%s, password:%s", WIFI_SSID, WIFI_PASS);
62	} else {
63	ESP_LOGE(TAG, "Unexpected event");
64	}

i.	ESP_ERROR_CHECK(esp_event_handler_instance_unregister(IP_EVENT, IP_EVENT_STA_GOT_IP, instance_got_ip));
b.	ESP_ERROR_CHECK(esp_event_handler_instance_unregister(WIFI_EVENT, ESP_EVENT_ANY_ID, instance_any_id));
65	vEventGroupDelete(s_wifi_event_group);
66	}

67	void http_post_task(void *pvParameters)
68	{
69	while (1) {
70	// Simulated data
71	float latitude = 40.712776;
72	float longitude = -74.005974;
73	int pulse = 75;
74	char post_data[128];
75	snprintf(post_data,sizeof(post_data),"{\"latitude\":%f,\"longitude\":%f,\
76	72pulse\":%d}", latitude, longitude, pulse);
77	esp_http_client_config_t config = {.url = SERVER_URL,.method = HTTP_METHOD_POST,
78	};
79	esp_http_client_handle_t client = esp_http_client_init(&config);
80	esp_http_client_set_header(client, "Content-Type", "application/json");
81	esp_http_client_set_post_field(client, post_data, strlen(post_data));
82	ESP_LOGI(TAG, "Sending HTTP POST request...");
83	esp_err_t err = esp_http_client_perform(client);
84	if (err == ESP_OK) {
ESP_LOGI(TAG, "HTTP POST Status = %d, content_length = %" PRId64,
i.	esp_http_client_get_status_code(client),
ii.	esp_http_client_get_content_length(client));
85	} else { ESP_LOGE(TAG, "HTTP POST request failed: %s", esp_err_to_name(err));
86	}

87	esp_http_client_cleanup(client);
88	vTaskDelay(6000 / portTICK_PERIOD_MS); // Send every 6 sec
89	}
90	}
91	void app_main(void)
92	{
93	ESP_ERROR_CHECK(nvs_flash_init());
94	wifi_init_sta();
95	xTaskCreate(&http_post_task, "http_post_task", 8192, NULL, 5, NULL);
96	}
Додаток Л
Перевірка на плагіат

 
